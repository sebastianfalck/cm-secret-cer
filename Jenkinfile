class JenkinsUtils {
    def steps
    JenkinsUtils(steps) { this.steps = steps }

    def getServer(ambiente, tipoAcceso) {
        def serverMap = [
            'drs'     : { -> steps.env.SERVER_DRS },
            'internal': { -> steps.env.SERVER_INTERNAL },
            'external': { -> steps.env.SERVER_EXTERNAL }
        ]
        if (ambiente?.toLowerCase() == 'drs') return serverMap['drs']()
        def key = tipoAcceso?.toLowerCase()
        return serverMap.get(key, serverMap['internal'])()
    }

    def getOcLoginCmd(server, token) {
        return "oc login --insecure-skip-tls-verify --server=${server} --token=${token}"
    }

    def getOcLogoutCmd() {
        return "oc logout"
    }

    def getChmodCmd(file) {
        return "chmod 644 ${file}"
    }

    def getCleanVarsCmd(nombre, resourceType) {
        return """oc set env deployment/${nombre} --list | grep ${resourceType} | awk '{print  \$2}' | while read VR; do echo \$VR; oc set env deployment/${nombre} \$VR-; done"""
    }

    def getSetFromCmd(nombre, resourceType) {
        return "oc set env deployment/${nombre} --from=${resourceType}/${nombre}"
    }

    def getScaleCmd(nombre, replicas) {
        return "oc scale deployment/${nombre} --replicas=${replicas}"
    }

    def getResourceCmd(resourceType, nombre, namespace, yamlFile) {
        def map = getResourceTypeMap()
        return map[resourceType]?.getResourceCmd?.call(nombre, namespace, yamlFile)
    }

    def getApplyCmd(resourceType, nombre) {
        def map = getResourceTypeMap()
        return map[resourceType]?.getApplyCmd?.call(nombre)
    }

    def getBackupCmd(resourceType, nombre, namespace, backupFile) {
        def map = getResourceTypeMap()
        return map[resourceType]?.getBackupCmd?.call(nombre, namespace, backupFile)
    }

    def getCreateCmd(resourceType, nombre) {
        def map = getResourceTypeMap()
        return map[resourceType]?.getCreateCmd?.call(nombre)
    }

    def existsCmd(resourceType, nombre, namespace) {
        def map = getResourceTypeMap()
        return map[resourceType]?.existsCmd?.call(nombre, namespace)
    }

    def deleteCmd(resourceType, nombre, namespace) {
        def map = getResourceTypeMap()
        return map[resourceType]?.deleteCmd?.call(nombre, namespace)
    }

    def extractCmd(resourceType, nombre) {
        def map = getResourceTypeMap()
        return map[resourceType]?.extractCmd?.call(nombre)
    }

    private def getResourceTypeMap() {
        return [
            'certificados': [
                getResourceCmd: { nombre, namespace, yamlFile ->
                    steps.unstash 'FileCer.zip'
                    steps.sh 'rm -rf certs && mkdir certs'
                    steps.sh 'unzip -j -o FileCer.zip -d certs'
                    def files = steps.sh(script: "ls certs", returnStdout: true).trim().split("\n")
                    def fromFileArgs = files.collect { f -> "--from-file=certs/${f}" }.join(' ')
                    return "oc create secret generic ${nombre}-file ${fromFileArgs} -n ${namespace} -o yaml --dry-run=client > ${yamlFile}"
                },
                getBackupCmd: { nombre, namespace, backupFile -> "oc get secret ${nombre}-file -n ${namespace} -o yaml > ${backupFile} || true" },
                existsCmd: { nombre, namespace -> "oc get secret ${nombre}-file -n ${namespace}" },
                getCreateCmd: { nombre -> "oc create secret generic ${nombre}-file" },
                getApplyCmd: { nombre -> "oc apply -f secret-${nombre}-file.yaml" },
                extractCmd: { nombre -> "oc extract secret/${nombre}-file --to=-" },
                deleteCmd: { nombre, namespace -> "oc delete secret ${nombre}-file -n ${namespace}" }
            ],
            'secret': [
                getResourceCmd: { nombre, namespace, yamlFile -> "oc create secret generic ${nombre} --from-env-file=datos.txt -n ${namespace} -o yaml --dry-run=client > ${yamlFile}" },
                getBackupCmd: { nombre, namespace, backupFile -> "oc get secret ${nombre} -n ${namespace} -o yaml > ${backupFile} || true" },
                existsCmd: { nombre, namespace -> "oc get secret ${nombre} -n ${namespace}" },
                getCreateCmd: { nombre -> "oc create secret generic ${nombre}" },
                getApplyCmd: { nombre -> "oc apply -f secret-${nombre}.yaml" },
                extractCmd: { nombre -> "oc extract secret/${nombre} --to=-" },
                deleteCmd: { nombre, namespace -> "oc delete secret ${nombre} -n ${namespace}" }
            ],
            'configmap': [
                getResourceCmd: { nombre, namespace, yamlFile -> "oc create configmap ${nombre} --from-env-file=datos.txt -n ${namespace} -o yaml --dry-run=client > ${yamlFile}" },
                getBackupCmd: { nombre, namespace, backupFile -> "oc get configmap ${nombre} -n ${namespace} -o yaml > ${backupFile} || true" },
                existsCmd: { nombre, namespace -> "oc get configmap ${nombre} -n ${namespace}" },
                getCreateCmd: { nombre -> "oc create configmap ${nombre}" },
                getApplyCmd: { nombre -> "oc apply -f configmap-${nombre}.yaml" },
                extractCmd: { nombre -> "oc extract configmap/${nombre} --to=-" },
                deleteCmd: { nombre, namespace -> "oc delete configmap ${nombre} -n ${namespace}" }
            ]
        ]
    }
}

pipeline {
    agent any
    environment {
        REPO_URL = ''
        REPO_CREDENTIALS = 'github-credentials'
        NOMBRE = "${params.NOMBRE}"
        AMBIENTE = "${params.AMBIENTE}"
        SERVER_INTERNAL = 'https://internal.openshift.example:6443'
        SERVER_EXTERNAL = 'https://external.openshift.example:6443'
        SERVER_DRS = 'https://drs.openshift.example:6443'
    }
    parameters {
        string(name: 'NOMBRE', defaultValue: '', description: 'Nombre del microservicio')
        choice(name: 'AMBIENTE', choices: ['dev', 'uat', 'prd', 'drs'], description: 'Ambiente')
        stashedFile '${params.NOMBRE}.zip'
        string(name: 'NAMESPACE', defaultValue: '', description: 'Namespace para validar según el ambiente')
    }
    stages {
        stage('Checkout Project') {
            steps {
                dir('project') {
                    git branch: 'main', url: env.REPO_URL, credentialsId: env.REPO_CREDENTIALS
                }
            }
        }

        stage('Leer configuración CSV') {
            steps {
                script {
                    // Leer configuración desde el archivo CSV
                    def configLines = readFile('project/ProjectsJenkinsCardifCSV.csv').readLines().findAll { it.trim() }
                    def headers = configLines[0].split(';').collect { it.trim() }
                    def fila = configLines.drop(1).collect { line ->
                        def valores = line.split(';')
                        def filaMap = [:]
                        headers.eachWithIndex { key, idx ->
                            filaMap[key] = (valores.size() > idx ? valores[idx] : '').trim()
                        }
                        filaMap
                    }.find { it['appName'] == env.NOMBRE }
                    writeFile file: "fila_${env.NOMBRE}.json", text: groovy.json.JsonOutput.toJson(fila)
                }
            }
        }

        stage('Validaciones') {
            steps {
                script {
                    // Validar ambiente permitido según rama
                    def branchName = env.GIT_BRANCH?.replaceFirst(/^origin\//, '') ?: 'dev'
                    def ambientesPorRama = [
                        'dev' : ['dev', 'uat'],
                        'main': ['dev', 'uat', 'prd', 'drs']
                    ]
                    def permitidos = ambientesPorRama[branchName] ?: ['dev', 'uat']
                    if (!permitidos.contains(env.AMBIENTE)) {
                        error "El ambiente '${env.AMBIENTE}' no está permitido en la rama '${branchName}'. Ambientes válidos: ${permitidos.join(', ')}"
                    }
                    echo "Ambiente '${env.AMBIENTE}' es válido para la rama '${branchName}'"

                    // Validar coincidencia de NOMBRE y stashedFile
                    def expectedFileName = "${env.NOMBRE}.zip"
                    if (expectedFileName != "${params.NOMBRE}.zip") {
                        error "El archivo adjunto (${expectedFileName}) no coincide con el nombre del microservicio (${env.NOMBRE}). Asegúrate de que el archivo se llame ${env.NOMBRE}.zip."
                    }
                    echo "Validación exitosa: El archivo adjunto coincide con el nombre del microservicio."

                    // Validar Namespace según ambiente
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def namespaceEsperado = fila["NameSpace${env.AMBIENTE.capitalize()}"]
                    if (params.NAMESPACE?.trim() != namespaceEsperado) {
                        error "El namespace proporcionado (${params.NAMESPACE}) no coincide con el esperado (${namespaceEsperado}) para el ambiente ${env.AMBIENTE}."
                    }
                    echo "Namespace validado correctamente: ${params.NAMESPACE}"

                    // Confirmación de país
                    def paisMicro = fila.country?.toLowerCase()
                    def partes = env.WORKSPACE.split(/[\\/]+/)
                    if (partes.size() < 2) {
                        error "Ruta demasiado corta: ${env.WORKSPACE}"
                    }
                    def paisRuta = partes[-2].toLowerCase()
                    echo "Pais desde ruta: ${paisRuta}, Pais desde CSV: ${paisMicro}"
                    if (paisMicro != paisRuta) {
                        error "El microservicio no pertenece a tu país: ${paisMicro} vs ${paisRuta}"
                    }
                }
            }
        }

        stage('Generar datos.txt si aplica') {
            steps {
                script {
                    unstash "${params.NOMBRE}.zip"
                    def zipFile = new File("${params.NOMBRE}.zip")
                    if (!zipFile.exists()) {
                        error "El archivo .zip no se encontró en el stash."
                    }

                    def unzipDir = new File('unzipped')
                    unzipDir.mkdirs()

                    sh "unzip -o ${zipFile} -d ${unzipDir}"

                    def certificadosZip = new File(unzipDir, 'Certificados.zip')
                    if (certificadosZip.exists()) {
                        def certsDir = new File(unzipDir, 'certs')
                        certsDir.mkdirs()
                        sh "unzip -o ${certificadosZip} -d ${certsDir}"

                        def certFiles = certsDir.listFiles()
                        if (certFiles.isEmpty()) {
                            error "Certificados.zip está vacío o no contiene archivos válidos."
                        }
                        echo "Certificados extraídos: ${certFiles.collect { it.name }.join(', ')}"
                    }

                    def configFile = new File(unzipDir, 'Configmap.txt')
                    if (configFile.exists()) {
                        if (configFile.text.trim().isEmpty()) {
                            error "Configmap.txt está vacío."
                        }
                        echo "Configmap.txt encontrado y procesado."
                    }

                    def secretsFile = new File(unzipDir, 'Secrets.txt')
                    if (secretsFile.exists()) {
                        if (secretsFile.text.trim().isEmpty()) {
                            error "Secrets.txt está vacío."
                        }
                        echo "Secrets.txt encontrado y procesado."
                    }

                    if (!certificadosZip.exists() && !configFile.exists() && !secretsFile.exists()) {
                        error "El archivo .zip no contiene Certificados.zip, Configmap.txt o Secrets.txt."
                    }

                    echo "Procesamiento del archivo .zip completado."
                }
            }
        }

        stage('Generar YAML del recurso') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def namespace = fila["NameSpace${env.AMBIENTE.capitalize()}"]
                    def server = utils.getServer(env.AMBIENTE, fila.usage)

                    def yamlFiles = []

                    def certificadosZip = new File('unzipped/Certificados.zip')
                    if (certificadosZip.exists()) {
                        def yamlFile = "certificados-${env.NOMBRE}-file.yaml"
                        yamlFiles << yamlFile
                        sh utils.getResourceCmd('certificados', env.NOMBRE, namespace, yamlFile)
                        echo "YAML generado para certificados: ${yamlFile}"
                    } else {
                        echo "Certificados.zip no encontrado, omitiendo generación de YAML para certificados."
                    }

                    def configFile = new File('unzipped/Configmap.txt')
                    if (configFile.exists()) {
                        def yamlFile = "configmap-${env.NOMBRE}.yaml"
                        yamlFiles << yamlFile
                        sh utils.getResourceCmd('configmap', env.NOMBRE, namespace, yamlFile)
                        echo "YAML generado para configmap: ${yamlFile}"
                    } else {
                        echo "Configmap.txt no encontrado, omitiendo generación de YAML para configmap."
                    }

                    def secretsFile = new File('unzipped/Secrets.txt')
                    if (secretsFile.exists()) {
                        def yamlFile = "secret-${env.NOMBRE}.yaml"
                        yamlFiles << yamlFile
                        sh utils.getResourceCmd('secret', env.NOMBRE, namespace, yamlFile)
                        echo "YAML generado para secret: ${yamlFile}"
                    } else {
                        echo "Secrets.txt no encontrado, omitiendo generación de YAML para secret."
                    }

                    if (yamlFiles.isEmpty()) {
                        echo "No se encontraron archivos válidos en el .zip, no se generaron YAMLs."
                    }

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        yamlFiles.each { yamlFile ->
                            echo "Aplicando YAML: ${yamlFile}"
                        }
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }

        stage('Backup') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def fecha = new Date().format("yyyy-MM-dd")
                    def namespace = fila["NameSpace${env.AMBIENTE.capitalize()}"]
                    def server = utils.getServer(env.AMBIENTE, fila.usage)
                    def backupDir = "/tmp/backup/${fila.country}/${fila.project}/${env.NOMBRE}/${env.AMBIENTE.toUpperCase()}/${env.RESOURCE_TYPE}"
                    def backupFile = "${backupDir}/${env.RESOURCE_TYPE}-${env.NOMBRE}-${fecha}.yaml"

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        sh "mkdir -p ${backupDir}"
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        sh utils.getBackupCmd(env.RESOURCE_TYPE, env.NOMBRE, namespace, backupFile)
                        sh utils.getChmodCmd(backupFile)
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }


        stage('Eliminar recurso si existe') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def namespace = fila["NameSpace${env.AMBIENTE.capitalize()}"]
                    def server = utils.getServer(env.AMBIENTE, fila.usage)

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        def exists = sh(script: utils.existsCmd(env.RESOURCE_TYPE, env.NOMBRE, namespace), returnStatus: true)
                        if (exists == 0) {
                            sh utils.deleteCmd(env.RESOURCE_TYPE, env.NOMBRE, namespace)
                        } else {
                            echo "No se encontró recurso para eliminar, continuando..."
                        }
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }

        stage('Recrear recurso y reiniciar despliegue') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def namespace = fila["NameSpace${env.AMBIENTE.capitalize()}"]
                    def server = utils.getServer(env.AMBIENTE, fila.usage)

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        sh utils.getApplyCmd(env.RESOURCE_TYPE, env.NOMBRE)
                        sh utils.extractCmd(env.RESOURCE_TYPE, env.NOMBRE)
                        sh utils.getScaleCmd(env.NOMBRE, 0)

                        if (env.RESOURCE_TYPE != 'certificados') {
                            sh utils.getCleanVarsCmd(env.NOMBRE, env.RESOURCE_TYPE)
                            sh utils.getSetFromCmd(env.NOMBRE, env.RESOURCE_TYPE)
                        }

                        sh utils.getScaleCmd(env.NOMBRE, 1)
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }
    }
}
