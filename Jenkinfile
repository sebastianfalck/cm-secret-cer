pipeline {
    agent any
    environment {
        REPO_URL = ''
        REPO_CREDENTIALS = 'github-credentials'
        NOMBRE = "${params.NOMBRE}"
        AMBIENTE = "${params.AMBIENTE}"
        RESOURCE_TYPE = "${params.RESOURCE_TYPE}"
        SERVER_INTERNAL = 'https://internal.openshift.example:6443'
        SERVER_EXTERNAL = 'https://external.openshift.example:6443'
        SERVER_DRS = 'https://drs.openshift.example:6443'
    }
    parameters {
        string(name: 'NOMBRE', defaultValue: '', description: 'Nombre del microservicio a consultar en el CSV')
        choice(name: 'AMBIENTE', choices: ['dev', 'uat', 'prd', 'drs'], description: 'Ambiente para determinar namespace y token')
        choice(name: 'RESOURCE_TYPE', choices: ['configmap', 'secret', 'certificados'], description: 'Tipo de recurso a crear')
        text(name: 'KEY_VALUE_PAIRS', defaultValue: '', description: 'Contenido para datos.txt')
        stashedFile 'FileCer.zip'
    }
    stages {
        stage('Checkout Project') {
            steps {
                dir('project') {
                    git branch: 'main', url: env.REPO_URL, credentialsId: env.REPO_CREDENTIALS
                }
            }
        }
        stage('Cargar variables del microservicio') {
            steps {
                script {
                    def archivo_csv = 'project/ProjectsJenkinsCardifCSV.csv'
                    def nombreProyecto = env.NOMBRE
                    def configLines = readFile(archivo_csv).readLines().findAll { it.trim() }
                    if (!configLines) error "El archivo CSV está vacío o no existe."
                    def headers = configLines[0].split(';').collect { it.trim() }
                    def appNameIdx = headers.findIndexOf { it.equalsIgnoreCase('appName') }
                    if (appNameIdx == -1) error "No se encontró la columna 'appName' en el CSV"
                    def fila = configLines.drop(1)
                        .collect { line ->
                            def valores = line.split(';')
                            def fila_limpia = [:]
                            headers.eachWithIndex { clave, idx ->
                                fila_limpia[clave.trim()] = (valores.size() > idx ? valores[idx] : '').trim().replaceAll(/^[\[]|[\]]\$/, '')
                            }
                            fila_limpia
                        }
                        .find { it['appName'] == nombreProyecto }
                    if (!fila) {
                        error "No se encontró el microservicio con appName: ${nombreProyecto}"
                    }
                    def jsonFila = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(fila))
                    writeFile file: "fila_${nombreProyecto}.json", text: jsonFila
                }
            }
        }
        stage('Crear archivo datos.txt') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    if ((fila.RESOURCE_TYPE == 'configmap' || fila.RESOURCE_TYPE == 'secret') && !params.KEY_VALUE_PAIRS?.trim()) {
                        error "KEY_VALUE_PAIRS no puede estar vacío para RESOURCE_TYPE = ${fila.RESOURCE_TYPE}"
                    }
                    writeFile file: 'datos.txt', text: params.KEY_VALUE_PAIRS
                }
            }
        }
        stage('Mostrar datos.txt') {
            steps {
                script {
                    echo "Contenido de datos.txt: ${readFile('datos.txt')}"
                }
            }
        }
        stage('Generar YAML') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        def yamlFile = env.RESOURCE_TYPE == 'certificados' ? "${env.RESOURCE_TYPE}-${env.NOMBRE}-file.yaml" : "${env.RESOURCE_TYPE}-${env.NOMBRE}.yaml"
                        def usageValue = fila.usage ?: 'internal'
                        def server = utils.getServer(env.AMBIENTE, usageValue)
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        def ocCmd = utils.getResourceCmd(env.RESOURCE_TYPE, env.NOMBRE, fila["Namespace${env.AMBIENTE.capitalize()}"] , yamlFile)
                        echo "Ejecutando: ${ocCmd}"
                        sh ocCmd
                        sh utils.getOcLogoutCmd()
                        echo "YAML generado: ${yamlFile}"
                    }
                }
            }
        }
        stage('Backup recurso actual en OpenShift') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        def backupFile = env.RESOURCE_TYPE == 'certificados' ? "tmp/${env.RESOURCE_TYPE}-${env.NOMBRE}-file-${fila.FECHA}.yaml" : "tmp/${env.RESOURCE_TYPE}-${env.NOMBRE}-${fila.FECHA}.yaml"
                        def usageValue = fila.usage ?: 'internal'
                        def server = utils.getServer(env.AMBIENTE, usageValue)
                        sh "mkdir -p tmp"
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        def ocGetCmd = utils.getBackupCmd(env.RESOURCE_TYPE, env.NOMBRE, fila["Namespace${env.AMBIENTE.capitalize()}"] , backupFile)
                        if (!ocGetCmd) error "Tipo de recurso no soportado: ${env.RESOURCE_TYPE}"
                        echo "Realizando backup: ${ocGetCmd}"
                        sh ocGetCmd
                        sh utils.getChmodCmd(backupFile)
                        sh utils.getOcLogoutCmd()
                        echo "Backup guardado en: ${backupFile}"
                    }
                }
            }
        }
        stage('Eliminar recurso existente si aplica') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        def usageValue = fila.usage ?: 'internal'
                        def server = utils.getServer(env.AMBIENTE, usageValue)
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        def existsCmd = utils.existsCmd(env.RESOURCE_TYPE, env.NOMBRE, fila["Namespace${env.AMBIENTE.capitalize()}"])
                        def deleteCmd = utils.deleteCmd(env.RESOURCE_TYPE, env.NOMBRE, fila["Namespace${env.AMBIENTE.capitalize()}"])
                        if (existsCmd && deleteCmd) {
                            def exists = sh(script: existsCmd, returnStatus: true)
                            if (exists == 0) {
                                echo "Recurso existente encontrado. Eliminando..."
                                sh deleteCmd
                            } else {
                                echo "No existe recurso previo con ese nombre."
                            }
                        }
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }
        stage('Modificación de deployment Yaml') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila["Token${env.AMBIENTE.capitalize()}"]]]]) {
                        def usageValue = fila.usage ?: 'internal'
                        def server = utils.getServer(env.AMBIENTE, usageValue)
                        sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                        def scaleDownCmd = utils.getScaleCmd(env.NOMBRE, 0)
                        def scaleUpCmd = utils.getScaleCmd(env.NOMBRE, 1)
                        if (env.RESOURCE_TYPE != 'certificados') {
                            def cleanVarsCmd = utils.getCleanVarsCmd(env.NOMBRE, env.RESOURCE_TYPE)
                            sh(script: cleanVarsCmd, label: 'Limpiando variables de entorno relacionadas')
                            def setFromCmd = utils.getSetFromCmd(env.NOMBRE, env.RESOURCE_TYPE)
                            sh(script: setFromCmd, label: 'Asignando variables desde el recurso')
                        }
                        sh(script: scaleDownCmd, label: 'Escalando deployment a 0 réplicas')
                        sh(script: scaleUpCmd, label: 'Escalando deployment a 1 réplica')
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }
        stage('Finalización del pipeline') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    echo "Pipeline finalizado exitosamente para el microservicio: ${fila.NOMBRE} en el ambiente: ${fila.AMBIENTE} y tipo de recurso: ${fila.RESOURCE_TYPE}"
                    def usageValue = fila.usage ?: 'internal'
                    def server = utils.getServer(env.AMBIENTE, usageValue)
                    sh utils.getOcLoginCmd(server, fila["Token${env.AMBIENTE.capitalize()}"])
                    def scaleDownCmd = utils.getScaleCmd(env.NOMBRE, 0)
                    def scaleUpCmd = utils.getScaleCmd(env.NOMBRE, 1)
                    sh(script: scaleDownCmd, label: 'Escalado final deployment a 0 réplicas')
                    sh(script: scaleUpCmd, label: 'Escalado final deployment a 1 réplica')
                    sh utils.getOcLogoutCmd()
                }
            }
        }
    }
}