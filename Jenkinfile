class JenkinsUtils {
    def steps
    JenkinsUtils(steps) { this.steps = steps }

    def getServer(ambiente, tipoAcceso) {
        def serverMap = [
            'drs'     : { -> steps.env.SERVER_DRS },
            'internal': { -> steps.env.SERVER_INTERNAL },
            'external': { -> steps.env.SERVER_EXTERNAL }
        ]
        if (ambiente?.toLowerCase() == 'drs') return serverMap['drs']()
        def key = tipoAcceso?.toLowerCase()
        return serverMap.get(key, serverMap['internal'])()
    }

    def getOcLoginCmd(server, token) {
        def cmd = "sudo oc login --insecure-skip-tls-verify --server=${server} --token=${token}"
        return cmd
    }

    def getOcLogoutCmd() {
        def cmd = "sudo oc logout"
        return cmd
    }

    def getChmodCmd(file) {
        return "chmod 644 ${file}"
    }

    def getCleanVarsCmd(nombre, resourceType) {
        def cmd = """sudo oc set env deployment/${nombre} --list | grep ${resourceType} | awk '{print  \$2}' | while read VR; do echo \$VR; sudo oc set env deployment/${nombre} \$VR-; done"""
        return cmd
    }

    def getSetFromCmd(nombre, resourceType) {
        def cmd = "sudo oc set env deployment/${nombre} --from=${resourceType}/${nombre}"
        return cmd
    }

    def getScaleCmd(nombre, replicas) {
        def cmd = "sudo oc scale deployment/${nombre} --replicas=${replicas}"
        return cmd
    }

    def getResourceCmd(resourceType, nombre, namespace, yamlFile, extra = null) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.getResourceCmd?.call(nombre, namespace, yamlFile, extra)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    def getApplyCmd(resourceType, nombre) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.getApplyCmd?.call(nombre)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    def getBackupCmd(resourceType, nombre, namespace, backupFile) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.getBackupCmd?.call(nombre, namespace, backupFile)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    def getCreateCmd(resourceType, nombre) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.getCreateCmd?.call(nombre)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    def existsCmd(resourceType, nombre, namespace) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.existsCmd?.call(nombre, namespace)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    def deleteCmd(resourceType, nombre, namespace) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.deleteCmd?.call(nombre, namespace)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    def extractCmd(resourceType, nombre) {
        def map = getResourceTypeMap()
        def cmd = map[resourceType]?.extractCmd?.call(nombre)
        return cmd?.startsWith('sudo ') ? cmd : "sudo ${cmd}"
    }

    private def getResourceTypeMap() {
        return [
            'certificados': [
                getResourceCmd: { nombre, namespace, yamlFile, extra ->
                    // Esta closure ya no debe invocar pasos; `extra` contiene los --from-file=... si aplica
                    if (extra && extra.trim()) {
                        return "oc create secret generic ${nombre}-file ${extra} -n ${namespace} -o yaml --dry-run=client > ${yamlFile}"
                    }
                    // Si no hay extra, asumimos que no hay archivos y retornamos comando que fallará en runtime
                    return "echo 'No hay archivos de certificados para ${nombre}'; exit 1"
                },
                getBackupCmd: { nombre, namespace, backupFile -> "sudo oc get secret ${nombre}-file -n ${namespace} -o yaml > ${backupFile} || true" },
                existsCmd: { nombre, namespace -> "sudo oc get secret ${nombre}-file -n ${namespace}" },
                getCreateCmd: { nombre -> "sudo oc create secret generic ${nombre}-file" },
                getApplyCmd: { nombre -> "sudo oc apply -f secret-${nombre}-file.yaml" },
                extractCmd: { nombre -> "sudo oc extract secret/${nombre}-file --to=-" },
                deleteCmd: { nombre, namespace -> "sudo oc delete secret ${nombre}-file -n ${namespace}" }
            ],
            'secret': [
                getResourceCmd: { nombre, namespace, yamlFile, extra ->
                    if (extra && extra.trim()) {
                        return "sudo oc create secret generic ${nombre} --from-env-file=${extra} -n ${namespace} -o yaml --dry-run=client > ${yamlFile}"
                    }
                    return "echo 'No se proporcionó archivo de secretos para ${nombre}'; exit 1"
                },
                getBackupCmd: { nombre, namespace, backupFile -> "sudo oc get secret ${nombre} -n ${namespace} -o yaml > ${backupFile} || true" },
                existsCmd: { nombre, namespace -> "sudo oc get secret ${nombre} -n ${namespace}" },
                getCreateCmd: { nombre -> "sudo oc create secret generic ${nombre}" },
                getApplyCmd: { nombre -> "sudo oc apply -f secret-${nombre}.yaml" },
                extractCmd: { nombre -> "sudo oc extract secret/${nombre} --to=-" },
                deleteCmd: { nombre, namespace -> "sudo oc delete secret ${nombre} -n ${namespace}" }
            ],
            'configmap': [
                getResourceCmd: { nombre, namespace, yamlFile, extra ->
                    if (extra && extra.trim()) {
                        return "sudo oc create configmap ${nombre} --from-env-file=${extra} -n ${namespace} -o yaml --dry-run=client > ${yamlFile}"
                    }
                    return "echo 'No se proporcionó archivo de configmap para ${nombre}'; exit 1"
                },
                getBackupCmd: { nombre, namespace, backupFile -> "sudo oc get configmap ${nombre} -n ${namespace} -o yaml > ${backupFile} || true" },
                existsCmd: { nombre, namespace -> "sudo oc get configmap ${nombre} -n ${namespace}" },
                getCreateCmd: { nombre -> "sudo oc create configmap ${nombre}" },
                getApplyCmd: { nombre -> "sudo oc apply -f configmap-${nombre}.yaml" },
                extractCmd: { nombre -> "sudo oc extract configmap/${nombre} --to=-" },
                deleteCmd: { nombre, namespace -> "sudo oc delete configmap ${nombre} -n ${namespace}" }
            ]
        ]
    }
}

pipeline {
    agent any
    environment {
        REPO_URL = ''
        REPO_CREDENTIALS = 'github-credentials'
        NOMBRE = "${params.NOMBRE}"
        NAMESPACE = "${params.NAMESPACE}"
        AMBIENTE = "${params.AMBIENTE}"
        SERVER_INTERNAL = 'https://internal.openshift.example:6443'
        SERVER_EXTERNAL = 'https://external.openshift.example:6443'
        SERVER_DRS = 'https://drs.openshift.example:6443'
    }
    parameters {
        string(name: 'NOMBRE', defaultValue: '', description: 'Nombre del microservicio')
        string(name: 'NAMESPACE', defaultValue: '', description: 'Namespace exacto donde se aplicarán los recursos (debe coincidir con el CSV para el ambiente seleccionado)')
        choice(name: 'AMBIENTE', choices: ['dev', 'uat', 'prd', 'drs'], description: 'Ambiente')
        // Nota: el contenido para datos.txt ahora se toma desde el adjunto (var.zip) — Configmap.txt y/o Secrets.txt
        stashedFile 'var.zip'
    }
    stages {
        stage('Validar ambiente permitido según rama') {
            steps {
                script {
                    def branchName = env.GIT_BRANCH?.replaceFirst(/^origin\//, '') ?: 'dev'
                    def ambientesPorRama = [
                        'dev' : ['dev', 'uat'],
                        'main': ['dev', 'uat', 'prd', 'drs']
                    ]
                    def permitidos = ambientesPorRama[branchName] ?: ['dev', 'uat']
                    if (!permitidos.contains(env.AMBIENTE)) {
                        error "El ambiente '${env.AMBIENTE}' no está permitido en la rama '${branchName}'. Ambientes válidos: ${permitidos.join(', ')}"
                    }
                    echo "Ambiente '${env.AMBIENTE}' es válido para la rama '${branchName}'"
                }
            }
        }

        stage('Checkout Project') {
            steps {
                dir('project') {
                    git branch: 'main', url: env.REPO_URL, credentialsId: env.REPO_CREDENTIALS
                }
            }
        }

        stage('Leer configuración CSV') {
            steps {
                script {
                    def configLines = readFile('project/ProjectsJenkinsCardifCSV.csv').readLines().findAll { it.trim() }
                    def headers = configLines[0].split(';').collect { it.trim() }
                    def fila = configLines.drop(1).collect { line ->
                        def valores = line.split(';')
                        def filaMap = [:]
                        headers.eachWithIndex { key, idx ->
                            filaMap[key] = (valores.size() > idx ? valores[idx] : '').trim()
                        }
                        filaMap
                    }.find { it['appName'] == env.NOMBRE }
                    writeFile file: "fila_${env.NOMBRE}.json", text: groovy.json.JsonOutput.toJson(fila)
                }
            }
        }

        stage('Validar NAMESPACE ingresado') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def expectedNamespace = fila.get("NameSpace${env.AMBIENTE.capitalize()}")?.trim()
                    def provided = params.NAMESPACE?.trim()
                    echo "Namespace esperado desde CSV para ambiente ${env.AMBIENTE}: ${expectedNamespace}"
                    echo "Namespace proporcionado por el desarrollador: ${provided}"
                    if (!provided) {
                        error "Parámetro NAMESPACE no fue provisto. Debe indicar el namespace donde se aplicarán los recursos."
                    }
                    if (expectedNamespace != provided) {
                        error "El NAMESPACE proporcionado ('${provided}') no coincide exactamente con el namespace configurado en el CSV ('${expectedNamespace}') para el ambiente ${env.AMBIENTE}."
                    }
                    echo "NAMESPACE validado correctamente."
                }
            }
        }

        stage('Confirmación de país') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def paisMicro = fila.get('country')?.toLowerCase()
                    def partes = env.WORKSPACE.split(/[\\/]+/)
                    if (partes.size() < 2) {
                        error "Ruta demasiado corta: ${env.WORKSPACE}"
                    }
                    def paisRuta = partes[-2].toLowerCase()
                    echo "Pais desde ruta: ${paisRuta}, Pais desde CSV: ${paisMicro}"
                    if (paisMicro != paisRuta) {
                        error "El microservicio no pertenece a tu país: ${paisMicro} vs ${paisRuta}"
                    }
                }
            }
        }

        stage('Procesar adjuntos') {
            steps {
                script {
                    // Recuperar el zip con los adjuntos
                    unstash 'var.zip'
                    echo "Intentando recuperar el archivo var.zip del stash..."
                    if (!steps.fileExists('var.zip')) {
                        error "El archivo var.zip no se encontró en el stash. Verifique que se haya guardado correctamente."
                    }

                    if (steps.fileExists('unzipped')) { sh 'rm -rf unzipped' }
                    sh 'mkdir -p unzipped'

                    sh 'unzip -o var.zip -d unzipped'

                    // Detectar tipos de recursos presentes en el adjunto
                    def detected = []

                    if (steps.fileExists('unzipped/Certificados.zip')) {
                        // extraer certificados para inspección posterior
                        if (steps.fileExists('unzipped/certs')) { sh 'rm -rf unzipped/certs' }
                        sh 'mkdir -p unzipped/certs'
                        sh 'unzip -o unzipped/Certificados.zip -d unzipped/certs'
                        def filesOut = sh(script: "ls -1 unzipped/certs || true", returnStdout: true).trim()
                        def certFiles = filesOut ? filesOut.split("\\n") : []
                        if (certFiles.size() == 0) {
                            echo "WARNING: Certificados.zip está vacío o no contiene archivos válidos. Se omitirá el tipo 'certificados'."
                        } else {
                            detected << 'certificados'
                            echo "Certificados extraídos: ${certFiles.join(', ')}"
                        }
                    }

                    if (steps.fileExists('unzipped/Configmap.txt')) {
                        def configText = steps.readFile('unzipped/Configmap.txt')
                        if (configText.trim().isEmpty()) {
                            error "ERROR: Configmap.txt está vacío. Abortando la ejecución para evitar aplicar cambios incompletos."
                        } else {
                            detected << 'configmap'
                            echo "Configmap.txt encontrado y procesado."
                        }
                    } else {
                        echo "INFO: Configmap.txt no encontrado en el adjunto."
                    }

                    if (steps.fileExists('unzipped/Secrets.txt')) {
                        def secretsText = steps.readFile('unzipped/Secrets.txt')
                        if (secretsText.trim().isEmpty()) {
                            error "ERROR: Secrets.txt está vacío. Abortando la ejecución para evitar aplicar cambios incompletos."
                        } else {
                            detected << 'secret'
                            echo "Secrets.txt encontrado y procesado."
                        }
                    } else {
                        echo "INFO: Secrets.txt no encontrado en el adjunto."
                    }

                    if (detected.isEmpty()) {
                        error "El archivo var.zip no contiene Certificados.zip, Configmap.txt o Secrets.txt."
                    }

                    // Persistir tipos detectados para usarlos en stages posteriores
                    writeFile file: 'detected_types.txt', text: detected.join(',')
                    echo "Tipos detectados: ${detected.join(', ')}"

                    echo "Procesamiento del archivo var.zip completado."
                }
            }
        }

        // Generar datos.txt eliminado: ahora usamos Configmap.txt y Secrets.txt directamente desde el adjunto

        stage('Generar YAMLs de los recursos detectados') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def namespace = fila.get("NameSpace${env.AMBIENTE.capitalize()}")
                    def server = utils.getServer(env.AMBIENTE, fila.get('usage'))

                    def yamlFiles = []
                    def typesProcessed = []

                    // Crear YAML para certificados si existen archivos en unzipped/certs o dentro de Certificados.zip
                    def certsDir = 'unzipped/certs'
                    def fromFileArgs = ''
                    def filesOut = sh(script: "ls -1 ${certsDir} 2>/dev/null || true", returnStdout: true).trim()
                    if (filesOut) {
                        def files = filesOut.split("\n")
                        fromFileArgs = files.collect { f -> "--from-file=${certsDir}/${f}" }.join(' ')
                    } else {
                        // Intentar extraer desde var.zip como fallback
                        if (steps.fileExists('var.zip')) {
                            sh 'rm -rf certs || true'
                            sh 'mkdir -p certs'
                            sh 'unzip -j -o var.zip "Certificados.zip" -d certs || true'
                            def filesOut2 = sh(script: "ls -1 certs 2>/dev/null || true", returnStdout: true).trim()
                            if (filesOut2) {
                                def files2 = filesOut2.split("\n")
                                fromFileArgs = files2.collect { f -> "--from-file=certs/${f}" }.join(' ')
                            }
                        }
                    }

                    if (fromFileArgs) {
                        def yamlFile = "secret-${env.NOMBRE}-file.yaml"
                        yamlFiles << yamlFile
                        typesProcessed << 'certificados'
                        sh utils.getResourceCmd('certificados', env.NOMBRE, namespace, yamlFile, fromFileArgs)
                        echo "YAML generado para certificados: ${yamlFile}"
                    } else {
                        echo "No se encontraron certificados para generar YAML."
                    }

                    // Crear YAML para configmap si existe el archivo
                    def configPath = 'unzipped/Configmap.txt'
                    if (steps.fileExists(configPath)) {
                        def rawCfg = steps.readFile(configPath)
                        def cfgLines = rawCfg.split(/\r?\n/).collect { it.trim() }
                        // Validar formato KEY=VALUE: permitir claves con letras, números, '_', '-', '.' y sin espacios
                        cfgLines.eachWithIndex { line, idx ->
                            if (!line || line.startsWith('#')) return
                            // Validar formato KEY=VALUE y que el VALOR no esté vacío
                            def m = (line =~ /^([A-Za-z0-9_.-]+)=(.*)$/)
                            if (!m) {
                                error "Formato inválido en ${configPath} (línea ${idx + 1}): '${line}'. Debe ser KEY=VALUE con KEY válido"
                            }
                            def val = m[0][2]
                            if (val == null || val.trim().length() == 0) {
                                error "Valor vacío en ${configPath} (línea ${idx + 1}): '${line}'. Los valores no pueden estar vacíos (KEY=)"
                            }
                        }
                        // Si pasamos validación y hay contenido útil, generamos el YAML
                        def nonEmpty = cfgLines.findAll { it && !it.startsWith('#') }
                        if (nonEmpty) {
                            def yamlFile = "configmap-${env.NOMBRE}.yaml"
                            yamlFiles << yamlFile
                            typesProcessed << 'configmap'
                            sh utils.getResourceCmd('configmap', env.NOMBRE, namespace, yamlFile, configPath)
                            echo "YAML generado para configmap: ${yamlFile}"
                        } else {
                            error "Configmap.txt existe pero no contiene pares clave=valor válidos: abortando."
                        }
                    } else {
                        echo "Configmap.txt no presente en adjunto: omitiendo configmap."
                    }

                    // Crear YAML para secret si existe el archivo
                    def secretPath = 'unzipped/Secrets.txt'
                    if (steps.fileExists(secretPath)) {
                        def rawSec = steps.readFile(secretPath)
                        def secLines = rawSec.split(/\r?\n/).collect { it.trim() }
                        // Validar formato KEY=VALUE
                        secLines.eachWithIndex { line, idx ->
                            if (!line || line.startsWith('#')) return
                            // Validar formato KEY=VALUE y que el VALOR no esté vacío
                            def m = (line =~ /^([A-Za-z0-9_.-]+)=(.*)$/)
                            if (!m) {
                                error "Formato inválido en ${secretPath} (línea ${idx + 1}): '${line}'. Debe ser KEY=VALUE con KEY válido"
                            }
                            def val = m[0][2]
                            if (val == null || val.trim().length() == 0) {
                                error "Valor vacío en ${secretPath} (línea ${idx + 1}): '${line}'. Los valores no pueden estar vacíos (KEY=)"
                            }
                        }
                        def nonEmptySec = secLines.findAll { it && !it.startsWith('#') }
                        if (nonEmptySec) {
                            def yamlFile = "secret-${env.NOMBRE}.yaml"
                            yamlFiles << yamlFile
                            typesProcessed << 'secret'
                            sh utils.getResourceCmd('secret', env.NOMBRE, namespace, yamlFile, secretPath)
                            echo "YAML generado para secret: ${yamlFile}"
                        } else {
                            error "Secrets.txt existe pero no contiene pares clave=valor válidos: abortando."
                        }
                    } else {
                        echo "Secrets.txt no presente en adjunto: omitiendo secret."
                    }

                    if (yamlFiles.isEmpty()) {
                        error "No se generaron YAMLs: no se detectó ningún recurso válido en el adjunto."
                    }

                    // Aplicar los YAMLs autenticados
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila.get("Token${env.AMBIENTE.capitalize()}")]]]) {
                        sh utils.getOcLoginCmd(server, fila.get("Token${env.AMBIENTE.capitalize()}") )
                        typesProcessed.each { type ->
                            echo "Aplicando recursos para tipo: ${type}"
                            sh utils.getApplyCmd(type, env.NOMBRE)
                        }
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }

        stage('Backup de recursos detectados') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def fecha = new Date().format("yyyy-MM-dd")
                    def namespace = fila.get("NameSpace${env.AMBIENTE.capitalize()}")
                    def server = utils.getServer(env.AMBIENTE, fila.get('usage'))

                    def detected = (readFile('detected_types.txt').trim()) ? readFile('detected_types.txt').trim().split(',') : []

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila.get("Token${env.AMBIENTE.capitalize()}")]]]) {
                        sh utils.getOcLoginCmd(server, fila.get("Token${env.AMBIENTE.capitalize()}") )
                        detected.each { type ->
                            def backupDir = "/tmp/backup/${fila.country}/${fila.project}/${env.NOMBRE}/${env.AMBIENTE.toUpperCase()}/${type}"
                            def backupFile = "${backupDir}/${type}-${env.NOMBRE}-${fecha}.yaml"
                            sh "mkdir -p ${backupDir}"
                            sh utils.getBackupCmd(type, env.NOMBRE, namespace, backupFile)
                            sh utils.getChmodCmd(backupFile)
                            echo "Backup generado para ${type}: ${backupFile}"
                        }
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }

        stage('Eliminar recurso si existe (detectados)') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def namespace = fila.get("NameSpace${env.AMBIENTE.capitalize()}")
                    def server = utils.getServer(env.AMBIENTE, fila.get('usage'))

                    def detected = (readFile('detected_types.txt').trim()) ? readFile('detected_types.txt').trim().split(',') : []

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila.get("Token${env.AMBIENTE.capitalize()}")]]]) {
                        sh utils.getOcLoginCmd(server, fila.get("Token${env.AMBIENTE.capitalize()}") )
                        detected.each { type ->
                            def exists = sh(script: utils.existsCmd(type, env.NOMBRE, namespace), returnStatus: true)
                            if (exists == 0) {
                                sh utils.deleteCmd(type, env.NOMBRE, namespace)
                                echo "Recurso ${type}/${env.NOMBRE} eliminado."
                            } else {
                                echo "No se encontró recurso ${type}/${env.NOMBRE} para eliminar."
                            }
                        }
                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }

        stage('Recrear recursos y reiniciar despliegue (detectados)') {
            steps {
                script {
                    def fila = readJSON file: "fila_${env.NOMBRE}.json"
                    def utils = new JenkinsUtils(this)
                    def namespace = fila.get("NameSpace${env.AMBIENTE.capitalize()}")
                    def server = utils.getServer(env.AMBIENTE, fila.get('usage'))

                    def detected = (readFile('detected_types.txt').trim()) ? readFile('detected_types.txt').trim().split(',') : []

                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'TOKEN', password: fila.get("Token${env.AMBIENTE.capitalize()}")]]]) {
                        sh utils.getOcLoginCmd(server, fila.get("Token${env.AMBIENTE.capitalize()}") )

                        detected.each { type ->
                            sh utils.getApplyCmd(type, env.NOMBRE)
                            // Extracción deshabilitada por petición del usuario
                            sh utils.getScaleCmd(env.NOMBRE, 0)

                            if (type != 'certificados') {
                                sh utils.getCleanVarsCmd(env.NOMBRE, type)
                                sh utils.getSetFromCmd(env.NOMBRE, type)
                            }

                            sh utils.getScaleCmd(env.NOMBRE, 1)
                            echo "Recreado recurso y reiniciado despliegue para tipo: ${type}"
                        }

                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }

        // Extracción de recursos deshabilitada por requerimiento: no se realiza ninguna extracción
    }
}
